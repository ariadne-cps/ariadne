/***************************************************************************
 *            modules.dox
 *
 *  Copyright  2006-20  Pieter Collins
 *
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#ifndef _ARIADNE_MODULES_H
#define _ARIADNE_MODULES_H

/*! \file modules.dox
 * \brief Documentation for %Ariadne modules.
 * \anchor modules
 */

/*! \brief The main %Ariadne namespace.
 */
namespace Ariadne {

/*!\defgroup UserModules User Modules
 */

/*! \defgroup SymbolicModule Symbolic Module
 *  \ingroup UserModules
 *  \brief Symbolic expressions in named variables.
 *
 * In this module, expressions in named variables can defined. These form the
 * building blocks for defining hybrid systems.
 */

/*!\defgroup SystemModule System Module
 * \ingroup UserModules
 * \brief Abstract base classes for system interface, and some commonly used systems.
 *
 * Systems fall into three basic classes, namely <em>discrete-time
 * systems</em>, <em>continuous-time systems</em>, and <em>hybrid-time
 * systems</em>, which are a combination of dicrete-time and hybrid-time
 * systems. There is a further subdivision into
 * <em>dynamical systems</em>, which are deterministic, <em>multivalued
 * systems</em>, which are nondeterministic, and
 * <em>control systems</em> in which control inputs and noise may be present.
 *
 * A system is defined by an algorithm to approximate the image of a basic set,
 * and possibly to approximate the derivative over a basic set.
 * It is <em>not</em> the purpose of the classes in the system module to
 * compute the image of denotable sets; this is the purpose of the Evaluation
 * module.
 *
 * See the page on \ref function_evaluation_page for more information.
 */

/*! \defgroup AnalysisModule Analysis Module
 *  \ingroup UserModules
 *  \brief Classes for computing the evolution and analysing the behaviour of a system.
 */


/*! \defgroup CoreModules Core Modules
 *
 *  \brief Core classes and functions used for both system specification and internal computation.
 */




/*!\defgroup LogicalModule Logical Module
 * \ingroup CoreModules
 * \brief Logical types, including \ref Boolean, \ref Sierpinskian and \ref Kleenean types.
 * \details In this module, we define %Ariadne's base logical types.
 * The main classes are \ref Ariadne::Boolean "Boolean",
 * \ref Ariadne::Sierpinskian "Sierpinskian", and \ref Ariadne::Kleenean "Kleenean".
 *
 * The Boolean class is a standard two-valued logical type with values \c true and \c false,
 * and represents the result of a decidable predicate.
 * The Sierpinskian class has two values, \c true and \c indeterminate,
 * and represents the result of a verifyable predicate.
 * The Kleenean class has three values, \c true, \c indeterminate and \c false,
 * and represents the result of a \em quasidecidable predicate.
 *
 * The Sierpinskian and Kleenean classes are "Effective" types, denoted by \ref Ariadne::EffectiveTag.
 * They are used to represent the results of predicates on exactly-specified objects from continuous (i.e. uncountable) spaces.
 * From the viewpoint of computable analysis, they can be considered as sequences of their values,
 * which stabilise as soon as a decision  (\c true or \c false) is reached.
 * In %Ariadne, this is realised by providing a method check(\ref Ariadne::Effort "Effort"),
 * which returns a "Validated" version of the class (denoted by  \ref Ariadne::ValidatedTag) containing one of its concrete values.
 * For example, if \c k is a Kleeanen object, then \c k.check(3) is a \ref Ariadne::ValidatedKleenean "ValidatedKleenean" object
 * which may have value \c true, \c indeterminate or \c false. Further, if \c k.check(3) is \c true or \c false, then k.check(4) has the same value.
 * Validated logical types are also used for the result of logical predicates on approximations to objects on continuous spaces with given error bounds.
 *
 * The \ref Ariadne::LowerKleenean "LowerKleenean" class also has the two values \c true and \c indeterminate.
 * The difference between LowerKleenean and Sierpinskian is that Sierpinskian is used where falsification is impossible,
 * which occurs when there are no robustly false values, such in the case of the inequality predicate,
 * whereas LowerKleenean is used when information which could be used to falsify the predicate has been lost,
 * such as testing positivity of a \ref Ariadne::LowerReal "LowerReal" number, for which only lower bounds are provided.
 * Conversions are possible Sierpinskian to Kleenean to LowerKleenean.
 * Similarly, a \ref Ariadne::UpperKleenean "UpperKleenean" class is provided with values \c false and \c indeterminate.
 *
 * The \ref Ariadne::NaiveKleenean "NaiveKleenean" class has values \c likely, \c indeterminate and \c unlikely,
 * and is used where only approximate information is available, so a rigorous assessment of truth or falseness cannot be made.
 * The corresponding finitary class is \ref Ariadne::ApproximateKleenean "ApproximateKleenean", which may represent a
 * the result of a predicate on a floating-point approximation to a real number without error bounds.
 * Note that ApproximateKleenean may be considered a \"\c ValidatedNaiveKleenean\" or as an \"\c Approximate\"\c Kleenean.
 * Although NaiveKleenean and ApproximateKleenean do not provide mathematically rigorous information, they may be useful in
 * scratch calculuations used to hot-start or precondition a rigorous calculuation.
 *
 * All logical classes support the standard operations of negation, conjunction (logical "and"), disjunction (logical "or") and exclusive-or.
 *
 * In order to obtain a built-in \c bool value from a \c Validated logical object,
 * the tests \ref Ariadne::definitely "definitely", \ref Ariadne::possibly "possibly", and \ref Ariadne::probably "probably" can be used.
 * Further, \ref Ariadne::decide "decide" can be used to convert any logical type to a boolean value,
 * returning \c probably for concrete (validated) logical types,
 * and checking abstract (effective) logical type with the default effort.
 *
 * An example of the use of logical predicates is given below:
 * \code
 * Real x = ...;
 * Kleeanean k = (x>0);
 *
 * Effort eff(5);
 * ValidatedKleenean vk = k.check(eff);
 *
 * MultiplePrecision pr(128);
 * ValidatedFloatMP vx = x.get(pr);
 * ValidatedKleenean vpx = (vx>0);
 *
 * // Check that if vk is false, then vpx cannot be true.
 * assert(possibly(vk) or not definitely(vpx));
 * \endcode
 */

/*!
\defgroup NumericModule Numeric Module
\ingroup CoreModules
\brief Numerical types, including \ref Integer, \ref Dyadic,  \ref Decimal, \ref Rational and \ref Real types,
generic types \ref Number "Number<P>",
double/multiple precision floating-point types \ref FloatDP and \ref FloatMP,
and correctly-rounded types \ref Value "Value<F>", \ref Ball "Ball<F,FE>", \ref Bounds "Bounds<F>"
\ref UpperBound "UpperBound<F>", \ref LowerBound "LowerBound<F>" and \ref Approximation "Approximation<F>".
For the mathematical theory of computability on real numbers, see the \ref numeric_page Page.

\details In this module, we define %Ariadne's base numerical types,
including support for interval arithmetic via balls and bounds.
The main concrete algebraic number types are \ref Integer,
\ref Dyadic, and \ref Rational.
A \ref Decimal number class is provided for user input.
The main real number type is \ref Real,
with directed versions \ref LowerReal and \ref UpperReal.
Generic numbers are defined using the \ref Number "Number<P>" templates,
with typedefs e.g. \ref EffectiveNumber for \ref Number<\ref EffectiveTag>.
Validated and approximate versions of real numbers are given by
\ref ValidatedReal and \ref ApproximateReal, and convergent sequences without
error bounds by \ref NaiveReal.

Concrete numerical types are defined in terms of the \ref FloatDP and \ref FloatMP
floating-point number classes.
These support rounded arithmetic and elementary functions using the \ref down
and \ref up tags (equivalantly, \ref downward and \ref upward).
Rounding to nearest is specified by the \ref near (equivalently, \ref to_nearest) tag.
Approximate arithmetic without control of the
rounding mode can be specified by the \ref approx rounding type.
Comparisons are performed considering these numbers as exact values, and must be decidable.
This means that these "raw" floating-point types should not be used directly, but
wrapped in one of the validated concrete approximation classes listed below.

Types supporting exact or rounded arithmetic may be used to define (validated)
approximations to numbers via the classes \ref Value "Value<F>",
\ref Ball "Ball<F,FE>", \ref Bounds "Bounds<F>"
\ref UpperBound "UpperBound<F>", \ref LowerBound "LowerBound<F>"
and \ref Approximation "Approximation<F>".

Note that to prevent accidental calls to approximate functions, all
non-exact operations (except explicitly-rounded operations on raw values)
must yield an \ref Approximation value.

%Positive numbers can be defined using the \ref Positive "Positive<X>" template.
A \ref Natural is a \ref Positive<\ref Integer>.

The following aliases are used for arithmetical operations:
 <dl><dt><dd><tt>nul(x)</tt> is equivalent to <tt>0*x</tt>
     <dt><dd><tt>pos(x)</tt> is equivalent to <tt>+x</tt>
     <dt><dd><tt>neg(x)</tt> is equivalent to <tt>-x</tt>
     <dt><dd><tt>sqr(x)</tt> is equivalent to <tt>x^2</tt>
     <dt><dd><tt>rec(x)</tt> is equivalent to <tt>1/x</tt>
     <dt><dd><tt>add(x,y)</tt> is equivalent to <tt>x+y</tt>
     <dt><dd><tt>sub(x,y)</tt> is equivalent to <tt>x-y</tt>
     <dt><dd><tt>mul(x,y)</tt> is equivalent to <tt>x*y</tt>
     <dt><dd><tt>div(x,y)</tt> is equivalent to <tt>x/y</tt>
     <dt><dd><tt>pow(x,y)</tt> is equivalent to <tt>x^y</tt>
 </dl>
Note that C++ does not support the power operator <tt>^</tt>. In Python, the power operator is denoted <tt>**</tt>.

We have the following operations on floating-point types
 - Exact arithmetic where possible:
   <dl><dt><dd><tt>%Float neg(Float);</tt>
       <dt><dd><tt>%Float abs(Float);</tt>
       <dt><dd><tt>%Float max(Float,Float);</tt>
   </dl>

 - Approximate and rounded arithmetic:
   <dl><dt><dd><tt>%Float add(near,Float,Float);</tt>
       <dt><dd><tt>%Float add(down,Float,Float);</tt>
       <dt><dd><tt>%Float add(up,Float,Float);</tt>
   </dl>

 - Arithmetic in the <em>current rounding mode</em>, or <em>opposite</em> rounding mode:
   <dl><dt><dd><tt>%Float add(rnd,Float,Float);</tt>
       <dt><dd><tt>%Float add(opp,Float,Float);</tt>
   </dl>

We use the following abbreviations for template parameters
for classes and concepts in this module:
 - \b Z: %Integer
 - \b W: %Dyadic
 - \b Q: %Rational
 - \b R: %Real
 - \b Y: %Generic %Number

 - \b PR: %Precision
 - \b F: %Float
 - \b X: %Concrete %Number

See the page \ref numeric_page for more information.

\internal The template names are currently not used consistently

 */

/*!
 * \defgroup LinearAlgebraModule Linear Algebra Module
 * \ingroup CoreModules
 * \brief \ref Vector "Vector<X>", \ref Matrix "Matrix<X>" and \ref Tensor "Tensor<N,X>" classes,
 * solution of linear equations, LU and QR factorisation and singular value decomposition.
 *
 * \details Basic types are represented by the classes \ref Ariadne::Vector "Vector"
 * and \ref Ariadne::Matrix "Matrix".
 * Specialist types include PermutationMatrix and DiagonalMatrix.
 * Operations such as vector sums and matrix-vector products are
 * accessed using operator overloading. %Expression templates and slices are
 * used to improve efficiency.
 *
 * More complicated matrix operations, such as factorisation, are represented
 * by sub-classes which contain the factorised data, from which the factors
 * can easily be extracted.
 *
 * Currently sparse and structured (e.g. triangular, symmetric, banded)
 * matrices are not directly supported, except to the extent needed for the
 * matrix decomposition classes, or for derivative tensors.
 *
 * All classes support exact arithmetic and interval arithmetic.
 *
 * We use the following abbreviations for template parameters for classes
 * in this module:
 *  - \b SCA: Scalar
 *  - \b VEC: Vector
 *  - \b MX: Matrix
 *
 */

/*!\defgroup DifferentiationModule  Differentiation Module
 * \ingroup CoreModules
 * \brief Support for automatic differentiation using Taylor expansions
 *
 * In this core module are the classes used to compute derivatives
 * of functions.
 */

/*! \defgroup FunctionModule Function Module
 *  \ingroup CoreModules
 *  \brief Functions on Euclidean space.
 *
 * In this module are the classes used to represent concrete functions in Euclidean space.
 * These functions can be used as the building blocks for geometric objects and dynamic systems.
 *
 *  \defgroup FunctionModelSubModule Function models
 *  \ingroup FunctionModule
 *  \brief Validated and approximate functions on bounded domains in Euclidean space.
 */


/*!\defgroup GeometryModule Geometry Module
 * \ingroup CoreModules
 * \brief Geometric calculus module.
 *
 * In this module are the classes used to represent sets and approximations to
 * sets. Sets fall into two classes, <em>basic sets</em> which are typically
 * simple sets which form a base for the topology, and <em>denotable sets</em>
 * which are unions of basic sets.
 *
 * The fundamental geometric operations are \c contains(Set,State),
 * \a disjoint(Set,Set) and subset(Set,Set). All these return \a tribool values,
 * where the indeterminate value is used to indicate a result which is either
 * not robust (e.g. the boundaries of two sets intersect but their interiors do
 * not) or which cannot be computed to the given precision.
 *
 * %Ariadne uses <em>fuzzy basic sets</em>, which are sets of sets defined using
 * interval data, to store intermediate results if these cannot be computed
 * exactly. These sets can be converted to ordinary basic sets by over- or
 * under-approximation. Alternatively, the fundamental binary predicates can
 * be computed directed for the fuzzy set types.
 * Denotable sets are never fuzzy.
 *
 * We use the following abbreviations for template parameters for classes in this module:
 *  - \b S: SetInterface
 *  - \b BS: BasicSet
 *  - \b DS: DenotableSet
 *  - \b LS: ListSet
 *  - \b GS: GridSet
 *  - \b PTS: PartitionTreeSet
 *
 * See \ref geometry_page for more information.
 *
 * \defgroup SetInterfaceSubModule Set interfaces
 * \ingroup GeometryModule
 * \brief Interfaces for various classes of sets.
 *
 * \defgroup ExactSetSubModule Exact sets
 * \ingroup GeometryModule
 * \brief Sets which can be defined exactly.
 *
 * Any set can be uniquely specified by the results geometric predicates involving
 * rectangles. Exact sets are defined by an interface in which these predicates are
 * defined.
 *
 * \defgroup BasicSetSubModule Basic sets
 * \ingroup GeometryModule
 * \brief Basic set classes.
 *
 * Basic sets are so-called because they form a base for the topology of the
 * space. Typically, basic sets are (a subclass of) convex polytopes or
 * ellipsoids. Basic sets must support the fundamental geometric predicates,
 * both within the class and with the Rectangle class. Additionally, basic sets
 * may support the optional geometric operations, but only if the class of set
 * under consideration is closed under that operation. The result may be
 * exactly computable if it involves no arithmetic (e.g. intersection of two
 * rectangles) or may need to be represented by a fuzzy set (e.g. Minkowski sum
 * of two rectangles).
 *
 * \defgroup ListSetSubModule List sets
 * \ingroup GeometryModule
 * \brief Denotable sets based on arbitrary lists of elements.
 *
 * \defgroup HybridSetSubModule Hybrid sets
 * \ingroup GeometryModule
 * \ingroup HybridModules
 * \brief Sets in spaces with many components.
 *
 * The state space of a hybrid system consists of many disconnected components,
 * one for each discrete mode. Hybrid sets consist of a union of many different
 * sets, one for each component of the state space.
 */


/*!\defgroup StorageModule Storage Module
 * \ingroup CoreModules
 * \brief Classes for representing discretised sets
 *
 * A <em>subdivision tree</em> is a binary tree describing a subdivision of
 * a rectangle (<em>unit cell</em>) into smaller cells. The subdivision is
 * described by a SubdivisionSequence giving the coordinate of the ith
 * subdivision, and a BinaryTree giving the subdivisions.
 *
 * e.g. The cell described by the SubdivisionSequence '[0,0,1,...]' and the
 * BinaryWord '[0,1,1]' is given by subdividing the unit interval twice in the
 * \f$x_0\f$ direction, first taking the lower half, and then the upper half,
 * and by subdividing once in the \f$x_1\f$ direction, taking the upper half.
 * This gives the dyadic rectangle '[0.25,0.5]x[0.5,1.0]'.
 *
 * Denotable sets are unions of basic sets of a simple kind, typically boxes.
 * In addition to the fundamental geometric predicates, denotable sets must also
 * support iteration through their elements, and union (join) with basic sets
 * and denotable sets of the same kind.
 */


/*!\defgroup SolverModule Solver Module
 * \ingroup CoreModules
 * \brief Classes and functions for solving algebraic equations, differential equations and optimisation problems (including constraint feasibility problems).
 *
 * The LinearProgram class supports construction and solution of linear
 * programming problems. Tests for feasibility only are also possible. The
 * computations are performed by a BLAS/LAPACK style lpslv() routing.
 */

/*!\defgroup OptimisationSubModule Optimisation solvers
 * \ingroup SolverModule
 * \brief Classes and functions for solving linear and nonlinear programming problems.
 *
 * The LinearProgram class supports construction and solution of linear
 * programming problems. Tests for feasibility only are also possible. The
 * computations are performed by a BLAS/LAPACK style lpslv() routing.
 */

/*!\defgroup DynamicsModule Dynamics Module
 * \ingroup CoreModules
 * \brief Classes and functions for analysing dynamic systems.
 */


/*! \defgroup OutputModules Output Modules
 *
 *  \defgroup GraphicsModule Graphical Output
 *  \ingroup OutputModules
 *  \brief Graphical output.
 *
 *  \defgroup SerializationModule Serialization
 *  \ingroup OutputModules
 *  \brief Input/Output to a text or html archive.
 *
 *  \defgroup CHomPModule Homology Output
 *  \ingroup OutputModules
 *  \brief Homology Output.
 */


/*! \defgroup HybridModules Hybrid System Modules
 */

/*! \defgroup HybridAutomataSubModule Hybrid automata
 *    \ingroup HybridModules
 *  \brief Hybrid system classes.
 */

/*! \defgroup HybridDynamicsSubModule Hybrid evolution
 *    \ingroup HybridModules
 *  \brief Classes and functions for analysing hybrid dynamic systems.
 */

/*!\defgroup ExternalModules External Modules
 */

} // namespace Ariadne

#endif /* _ARIADNE_MODULES_H */
