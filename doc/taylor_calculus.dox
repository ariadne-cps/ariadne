/***************************************************************************
 *            taylor_calculus.dox
 *
 *  Copyright  2009  Pieter Collins
 *
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/*!
 * \file taylor_calculus.dox
 * \brief Documentation Ariadne's Taylor calculus
 */

namespace Ariadne {

/*!

\page python_tutorial_page Python Interface and Functional Calculus

On this page, we explain how to use Ariadne's internal function calculus via the Python interface. First, a brief overview of the numerical types and linear algebra operations are given in the \ref python_tutorial_numerical and \ref python_tutorial_linear_algebra sections. A guide to the nonlinear functions available is given in \ref python_tutorial_functional_calculus. Finally, a guide to the numerical Taylor calculus is given in \ref python_tutorial_taylor_calculus.

\dontinclude examples/tutorial.py

\section python_tutorial_numerical Numerical Types

%Ariadne supports four basic numerical types, Integer, Rational, Float and Interval. The Integer and Rational types are only supported if the GNU Multiple-Precision library (GMP) is installed, and are mostly used for system definition. The Float type is based on the IEEE double-precision type (native) in Python, and the Interval type is an internal type supporting outwardly-rounded interval arithmetic with interval endpoints.

The Integer class supports integers of arbitrary size.

\skipline Integer

The Rational class supports exact representation of rational numbers.

\skipline Rational

%Ariadne uses C++/Python's built-in floating-point type to provide a Float class.

\skipline Float

%Ariadne supplies an Interval class supporting outward-rounded interval arithmetic

\skipline Interval

Note that when creating an interval from floating-point values, the numerical literals are first converted to the nearest exactly representable number by the interpreter.
\skipline Interval
\skipline Interval

To obtain an outwardly-rounded interval, use the Rational class if possible.
\skipline Interval
\skipline Interval




\section python_tutorial_linear_algebra Linear Algebra

%Ariadne supports linear algebra operations based on Vector and Matrix classes. In the C++ library, these types are parameterised by the scalar type (either Float or Interval). In the Python interface, only interval versions are provided.

%Vector and matrix classes can be constructed using Python lists.
\skipline Vector
\skipline Matrix

As well as matrix and vector arithmetic, %Ariadne provides a \c solve routine for solving systems of linear equations:

\skipline solve





\section python_tutorial_functional_calculus Functional Calculus

%Ariadne supports nonlinear functions by means of two abstract classes, the RealScalarFunction for scalar functions \f$f:\R^m\rightarrow\R\f$ and the RealVectorFunction for functions \f$f:\R^m\rightarrow\R^n\f$. These interfaces cannot be directly manipulated. Instead, they can be converted to numerical ScalarTaylorFunction and VectorTaylorFunction types which can then be worked with.

\subsection taylor_calculus_nonlinear User-Defined Functions

The RealScalarFunction and RealVectorFunction also allow the creation of %Ariadne functions.

\skipline argument_size
\until evaluate

\subsection taylor_calculus_polynomial Polynomial Calculus

\dontinclude examples/tutorial.py

The RealPolynomial class provide concrete implementations of the function calculus.

A PolynomialExpression represents a scalar polynomial function in multiple variables, with coefficients represented by intervals to take into account roundoff error. A polynomial expression can be created by using the PolynomialExpression.variable(n,j), which creates the polynomial \f$p(x)=x_j\f$ for \f$x\in\R^n\f$:

\skipline RealPolynomial.coordinate

We can define a shorthand for creating polynomials:

\skipline def poly
\until return

The standard arithmetical operations are available for polynomial expressions:

\skipline +p
\until c*p




\section python_tutorial_taylor_calculus Taylor Calculus

\dontinclude examples/tutorial.py

The core type is a ScalarTaylorFunction, which is a polynomial representation \a p of a function \a f on a box \a D in Euclidean space with uniform error \a e:
\f[ f(x) = p(x)\pm e \text{ for } x\in D . \f]

Rather than represent a Taylor function by the polynomial \a p itself, we use a scaled model \a m such that
\f[ m(\xi) = p(s(\xi)) \f]
where
\f[ s:[-1,+1]^n \rightarrow [a_1,b_1]\times\cdots\times[a_n,b_n] = D\f]
is the scaling function given by
\f[ s_i(\xi) = \frac{a_i+b_i}{2} + \frac{b_i-a_i}{2} \xi_i . \f]
The use of the scaled model \a m gives better accuracy over the domain of the expression.

\sa \ref function_models_page

\subsection taylor_calculus_creating Creating Taylor functions

The simplest way to create a Taylor function is to use the named constructor coordinate(D,j,swp), which constructs a Taylor function for the function \f$f(x)=x_j\f$ on the domain \f$D\f$ using the \e sweeper to control the accuracy:

\skipline ScalarTaylorFunction.coordinate

It is possible to create a list of all \f$n\f$ variables on \f$D\in\R^n\f$:
\skipline ScalarTaylorFunction.coordinate

To save typing, give shorthand names to the variables:
\skipline x
\until z

We can even make a shorthand function to create new Taylor expressions.
\skipline def t
\until return

A Taylor expression can also be constructed as an approximations to any object satisfying the ExpressionInterface type, including the PolynomialExpression. The domain of the expression has to be given.

\skipline =ScalarTaylorFunction


The following functions are available to inspect the Taylor expression.
The domain() function returns the domain of validity \a D.
The codomain() returns the over-approximation to the image of the domain given by
\f[ c_0 \pm \left(\textstyle\sum_{|\alpha|\neq0} |c_\alpha| + e \right) . \f]
The range() also gives an over-approximation to the image of the domain, but may be more accurate (and slower).
The polynomial() function gives an interval polynomial representation of the function which is only valid on the domain.
\skipline .domain
\skipline .codomain
\skipline .range
\skipline .polynomial

\subsection taylor_calculus_arithmetic Arithmetical Operators

The standard arithmetical operations are available between Taylor expressions. In all cases, the result enclosed all possible functions represented by the arguments.
\skipline +

Mixed operations with Float and Interval scalars are also supported:
\skipline +
\until c/x
\skipline +
\until i/x

Inplace operations are supported where they can be implemented efficiently:
\skipline x+=y
\until x/=

\subsection taylor_calculus_functions Algebraic and Transcendental Functions

The comparison functions \c min, \c max and \c abs are provided.
abs(x) returns x if is (provably) positive on the entire domain, -x if x is (provably) negative on the entire domain, and the interval constant abs(x.range()) otherwise. max(x,y) can be implemented as ( x + y + abs(x-y) )/2

\skipline min

The standard %Ariadne arithmetical functions \c neg, \c rec, \c sqr and \c pow are provided.
The \c rec function throws a DivideByZeroException if zero lies in the codomain of \a x, as does \c pow(x,n) for negative \a n.

\skipline neg

The standard algebraic and transcendental functions are also given. The \c sqrt and \c log functions throw a DomainException if the codomain of the expression is not positive. The \c tan function throws a DivideByZeroException if \a cos(x) becomes zero over the domain.

\skipline sqrt
\until tan

\subsection taylor_calculus_combining Joining Expressions to make Functions

We can also change the domain of definition of the expression using the \c embed function. The result of \f$\mathrm{embed}(D_0,f_1,D_2)\f$ is the function \f$f:D_0\times D_1\times D_2 \rightarrow \R\f$ given by \f$\hat{f}(x_0,x_1,x_2)=f(x_1)\f$.

\skipline embed

We can combine TaylorExpression objects into TaylorFunction objects using the \c join function. The domain of each of the subexpressions must be the same. The result of \c join(f,g) is the function given by \f$\mathrm{join}(f,g)(x)=(f(x),g(x))\f$.

\skipline join

We can combine TaylorExpression objects into TaylorFunction objects using the \c combine function. The result of \c combine(f,g) is the function given by \f$\mathrm{combine}(f,g)(x,y)=(f(x),g(y))\f$.

\skipline combine

\subsection taylor_calculus_composition Composition

The main use of the Taylor calculus is to perform composition of functions and solution of equations.

We can compose TaylorFunction objects \f$f\f$ and \f$h\f$ to obtain the function \f$f\circ h\f$.

\skipline compose

The codomain of \a g must be a subset of the domain of \a f.
\skipline assert

We can also compose a TaylorExpression \f$f\f$ and TaylorFunction \f$g\f$ to obtain a Taylor expression \f$f\circ g\f$.

\until compose

We can also compose Expression interface objects and FunctionInterface objects.

\subsection taylor_calculus_algebraic Solving Algebraic Equations

We can use Taylor functions to solve parameterised algebraic equations using the operator \c implicit.
If \f$f:D_1\times D_2\rightarrow \R^n\f$ with \f$D_2\subset\R^n\f$ then the operator \c implicit(f) attempts to compute a function \a h such that \f$f(x,h(x))=0\f$ for \f$x\in D_m\f$. The function \f$h\f$ must satisfy \f$h(D_1)\subset D_2\f$.

\skipline implicit

In the case of a Taylor expression, the \c implicit function applied to \f$f:D_1\times I_2\rightarrow\R\f$ returns a Taylor expression \f$h:D_1\rightarrow I_2\subset\R\f$ such that \f$h(x,h(x))=0\f$.

\subsection taylor_calculus_differential Computing (Anti)Derivatives and Solving Differential Equations

The antiderivative method computes a Taylor expression \f$\int^{x_j} f\f$ such that \f$\frac{\partial}{\partial x_j} \int^{x_j} f = f\f$:
\skipline antiderivative

If \f$f\f$ is a Taylor expression, then \c derivative(f,j) computes the derivative of \a f with respect to the \a j<sup>th</sup> independent variable. Since the derivative is only well-defined if the error term is zero (otherwise there are represented functions with arbitrary high derivatives) a prerequisite of the operator is that the error is zero:

\skipline derivative

If a derivative with respect to more than one variable is requires, the form \c derivative(f,[j1,...,jk]) can be used, where \c [j1,...,jk] is an array of indices:

\skipline derivative



Given a function \f$f:B\rightarrow\R^n\f$, a domain \a D which is a subset of \a B and a time step \a h, a function \f$\phi:D\times[-h,+h]\rightarrow B\f$ satisfying \f$\frac{d}{dt}\phi(x,t) = f(\phi(x,t))\f$ and \f$\phi(x,0)=x\f$ can be computed using the \c flow operator:

If \f$f\f$ is a Taylor function, then the domain \a B is the domain of the function model, so the flow can be computed using:

\skipline flow(

\subsection taylor_calculus_comparisons Comparisons

Taylor expressions \a f<sub>1</sub> and \a f<sub>2</sub> can be compared to see if one gives a better approximation than the other using the \c refines operator. If \c refines(f<sub>1</sub>,f<sub>2</sub>) is \c True, then any function represented by \a f<sub>1</sub> is also represented by \a f<sub>2</sub>. The result may be \c Indeterminate if it cannot be determined up to numerical error whether \a f<sub>1</sub> refined \a f<sub>2</sub> or not.

If \f$f_1(x)=p_1(x)+e_1\f$ and \f$f_2(x)=p_2(x)+e_2\f$, then \c refines(f_1,f_2) yields \c True if \f$|p_1-p_1|+e_1 \leq e_2\f$.

Taylor expressions \a f<sub>1</sub> \a f<sub>2</sub> can be compared to see if there is a function \a f modelled by both.
If \f$f_1(x)=p_1(x)+e_1\f$ and \f$f_2(x)=p_2(x)+e_2\f$, then \c intersect(f_1,f_2) yields \c True if \f$|p_1-p_1| \leq e_1 + e_2\f$.


\skipline refines
\skipline disjoint
\skipline intersection


\subsection taylor_calculus_contractors Contractors

We can use a variant of the interval Newton method to improve solutions to algebraic equations.

\skipline Newton
\until derivative

We can use Picard iteration to improve solutions to differential equations.

\skipline Picard
\until antiderivative

\sa \ref function_model_contractors

*/







} // namespace Ariadne